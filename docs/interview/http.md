---
id: http
title: HTTP 面试相关总结
---

import TOCInline from '@theme/TOCInline';

<TOCInline toc={toc} />

### GET 和 POST 的区别？

POST 和 GET 是 HTTP 请求的两种方法。

从应用场景上来说，GET 请求是一个幂等的请求，一般 GET 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页。而 POST 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。

因为不同的应用场景，所以浏览器一般会对 GET 请求缓存，但很少对 POST 请求缓存。

从发送的报文格式来说，GET 请求的报文中实体部分为空，POST 请求的报文中实体部分一般为向服务器发送的数据。

但是 GET 请求也可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 POST 请求来说，一个方面是不太安全，因为请求的 url 会被保留在历史记录中。并且浏览器由于对 url 有一个长度上的限制，所以会影响 GET 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。还有就是 POST 的参数传递支持更多的数据类型。

### TLS/SSL 中什么一定要用三个随机数来生成会话密钥？

客户端和服务器都需要生成随机数，以此来保证每次生成的秘钥都不相同。使用三个随机数，是因为 SSL 的协议默认不信任每个主机都能产生完全随机的数，如果只使用一个伪随机的数来生成秘钥，就很容易被破解。通过使用三个随机数的方式，增加了自由度，一个伪随机可能被破解，但是三个伪随机就很接近于随机了，因此可以使用这种方法来保持生成秘钥的随机性和安全性。

### SSL 连接断开后如何恢复？

一共有两种方法来恢复断开的 SSL 连接，一种是使用 session ID，一种是 session ticket。

使用 session ID 的方式，每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，而不用重新生成一把。目前所有的浏览器都支持这一种方法。但是这种方法有一个缺点是，session ID 只能够存在一台服务器上，如果我们的请求通过负载平衡被转移到了其他的服务器上，那么就无法恢复对话。

另一种方式是 session ticket 的方式，session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等。这样不管我们的请求是否转移到其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。

### DNS 为什么使用 UDP 协议作为传输层协议？

DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 TCP 协议时造成的连接时延。因为为了得到一个域名的 IP 地址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢，因为大多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。

使用 UDP 协议作为 DNS 协议会有一个问题，由于历史原因，物理链路的最小 `MTU=576`，所以为了限制报文长度不超过 576，UDP 的报文段的长度被限制在 512 个字节以内，这样一旦 DNS 的查询或者应答报文，超过了 512 字节，那么基于 UDP 的 DNS 协议就会被截断为 512 字节，那么有可能用户得到的 DNS 应答就是不完整的。这里 DNS 报文的长度一旦超过限制，并不会像 TCP 协议那样被拆分成多个报文段传输，因为 UDP 协议不会维护连接状态，所以我们没有办法确定那几个报文段属于同一个数据，UDP 只会将多余的数据给截取掉。为了解决这个问题，我们可以使用 TCP 协议去请求报文。

DNS 还存在的一个问题是安全问题，就是我们没有办法确定我们得到的应答，一定是一个安全的应答，因为应答可以被他人伪造，所以现在有了 DNS over HTTPS 来解决这个问题。

### 当你在浏览器中输入 URL 并按下回车之后发生了什么？

1. **解析 DNS**：解析输入的 URL 中的域名得到服务器主机 IP 地址。首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。
2. **建立连接**：通过 TCP 三次握手建立浏览器与服务器间的连接。第一次握手，客户端发送一个带 `SYN=1,Seq=x` 的数据包到服务端，并进入 SYN_SEND 状态，等待服务器确认。第二次握手，服务端确认收到客户端发来的请求，发回一个带 `SYN=1,ACK=x+1,Seq=y` 的数据包到客户端，以示传达确认信息，并进入 `SYN_RECV` 状态。第三次握手，客户端确认收到服务端发来的请求，再回传一个带 `ACK=y+1,Seq=z` 的数据包到服务端，包发送完毕后，客户端与服务端都进入 `ESTABLISHED` 状态。完成 TCP 三次握手。
3. 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。第一次握手，由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。第二次握手，服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。第三次握手，客户端收到后，先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。第四次握手，服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。此时双方都有了三个随机数，按照之前所约定的加密方再传输。
4. 客户端发送请求到服务器端，服务器端解析请求并返回一个 html 文件作为响应。
5. **解析并渲染页面**：浏览器接收到响应后，对 html 文件进行解析，开始页面的渲染过程。浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会阻塞页面渲染。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。
6. **断开连接**：当数据传送完毕，需要断开 TCP 连接，此时发起 TCP 四次挥手。
