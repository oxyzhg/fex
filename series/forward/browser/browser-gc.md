---
id: gc
title: 垃圾回收
---

## 什么是垃圾数据

在一些数据不被需要的时候，它就是垃圾数据，垃圾数据占用的内存就应该被回收。

## 垃圾回收算法

垃圾回收可分为以下几个步骤：

1. 标记空间中的可达数据
2. 回收不可达值占据的内存
3. 内存整理

### 标记空间中的可达数据

V8 采用的是**可达性**（reachability）算法来判断堆中的对象是否应该被回收。

这个算法的思路是这样的：

- 从根节点（Root）出发，遍历所有的对象
- 可以遍历到的对象，是可达的（reachable）
- 没有被遍历到的对象，不可达的（unreachable）

在浏览器环境下，根节点有很多，主要包括这几种：

- 全局变量 window，位于每个 iframe 中
- 文档 DOM 树
- 存放在栈上的变量

这些根节点不是垃圾，不可能被回收。

### 回收不可达值占据的内存

在所有的标记完成之后，统一清理内存中所有不可达的对象。

### 内存整理

- 在频繁回收对象后，内存中就会存在大量不连续空间，专业名词叫「内存碎片」。
- 当内存中出现了大量的内存碎片，如果需要分配较大的连续内存时，就有可能出现内存不足的情况。
- 所以最后一步是整理内存碎片。 (但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器)

## 什么时候回收垃圾

浏览器进行垃圾回收的时候，会暂停 JavaScript 脚本，等垃圾回收完毕再继续执行。对于普通应用这样没什么问题，但对于 JS 游戏、动画对连贯性要求比较高的应用，如果暂停时间很长就会造成页面卡顿。

### 分代收集

浏览器将数据分为两种，分别是**临时对象**和**长久对象**。

- **临时对象**：大部分对象在内存中存活的时间很短。比如函数内部声明的变量，或者块级作用域中的变量。当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。这类对象很快就变得不可访问，应该快点回收。
- **长久对象**：生命周期很长的对象，比如全局的 window、DOM、Web API 等。这类对象可以慢点回收。

这两种对象对应不同的回收策略，所以，V8 把堆分为**新生代**和**老生代**两个区域，新生代中存放临时对象，老生代中存放持久对象。并且让副垃圾回收器、主垃圾回收器，分别负责新生代、老生代的垃圾回收。这样就可以实现高效的垃圾回收。

#### 主垃圾回收器

负责老生代的垃圾回收，有两个特点：对象占用空间大，对象存活时间长。

它使用**标记-清除**的算法执行垃圾回收。概括为以下几步：

1. 标记垃圾
2. 清理垃圾
3. 内存整理

第一步，给所有垃圾数据作标记

- 从一组根元素开始，递归遍历这组根元素。
- 在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。

第二步，将标记为垃圾的数据清理掉

![GC Step](/img/posts/gc-sep-1.png)

第三步，多次执行标记-清除后，会产生大量不连续的内存碎片，需要进行内存整理

![](/img/posts/gc-sep-2.png)

#### 副垃圾回收器

负责新生代的垃圾回收，通常只支持 1~8M 的容量。

新生代被分为两个区域：一半是**对象区域**，一半是**空闲区域**。如下图：

![GC V8](/img/posts/gc-v8.png)

新加入的对象都被放入对象区域，等对象区域快满的时候，会执行一次垃圾清理。概括为以下几步：

1. 标记对象区垃圾
2. 复制对象区的存活数据到空闲区，并排序
3. 对调空闲区与对象区

第一步，给对象区域所有垃圾数据作标记

第二步，标记完成后，存活的对象被复制到空闲区域，并且将他们有序的排列一遍

![GC Step](/img/posts/gc-sep-3.png)

副垃圾回收器没有碎片整理。是因为空闲区域里此时是有序的，没有碎片也就不需要整理了。

第三步，复制完成后，对象区域会和空闲区域进行对调，将空闲区域中存活的对象放入对象区域里

![GC Step](/img/posts/gc-sep-4.png)

这样，就完成了垃圾回收。

因为副垃圾回收器操作比较频繁，为了执行效率，一般新生区的空间会被设置得比较小。一旦检测到空间装满了，就执行垃圾回收。

一句话总结分代回收就是：将堆分为新生代与老生代，多回收新生代，少回收老生代。这样就减少了每次需遍历的对象，从而减少每次垃圾回收的耗时。

![GC Step Summary](/img/posts/gc-sep-summary.png)

### 增量收集

如果脚本中有许多对象，引擎一次性遍历整个对象，会造成一个长时间暂停。所以引擎将垃圾收集工作分成更小的块，每次处理一部分，多次处理。这样就解决了长时间停顿的问题。

### 闲时收集

垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。
